Cours de Calucl et Complexité

Cours du 11/09/2014

JFLAP : plateforme de test d'automate, de gramR, etc (cg Google).


Classifier des langages (rationnels, algébriques et récursifs), des automates associés et des gramR les engendrant.
Le décidabilité et la complexité en dépendent.


Automate finis déterministes :
-Simulation d'une machine très simple :
	-mémorisation d'un état
	-programme sous forme de graphe étiquetté indiquant les transitions possibles
-Cette machine lit un mot en entrée
-ce mot décrit une suite d'action et progresse d'état en état, jusqu'a lecture du mot.
-Et dit s'il fait partir d'un langage donné, après avoir atteint un état final.

Un automate déterministe fini est le quintuplet :
-K ensemble fini non vide d'état
-Epsilon : alphabet (ensemble non vide de lettres)
-delta : fonction de transistion K x Epsilon -> K
	ð(q, sigma) =q'


Machines de Turing :
Une machine de Turing est constituée 
-d'un contrôle (ensemble finis d'état et de transitions
-d'un ruban infini à droite
-d'une tête sur le riban qui peut lire et écrire et qui peut se déplacer dans les deux directions d'un caractère à la fois.

A chque étape, en fonction de l'état courant et du symbole courant, la machine :
-change d'état,
-écrit un symbole à l'emplacement courant,
-déplace le tête d'une position à droite ou à gauche.

Initialement la machine est dans un état initial (sic)

Le symbole qui désigne le blanc (#) n'appartient pas à l'alphabet, mais peut être lu.
Pour simplifier l'écriture des configurations, on introduit une notation abbréviée sous la forme : (état courant, contenu du ruban où le symbole courant est souligné)

Ainsi, la config (q, e, a, bcdf) s'écrit (q, _a_ bcdf)  oui, le a est souligné (je peut pas le faire en ascii).

/!\ Je passe en notation latex pour la suite

Soit une machine de Turinf M=(K, \Sigma, \Gamma, \delta, q_0) et deux configurations (q_1, w_1, a_1, u_1) et (q_2, w_2, a_2, u_2). On dit que (q_1, w_1, a_1, u_1) conduit à (q_2, w_2, a_2, u_2) en une étape ssi voir démonstration.
On note cela (q_1, w_1, a_1, u_1) \Tcouché_M (q_2, w_2, a_2, u_2)

\delta : une fonction partielle : pour chaque doublet (etat, caractère) de la fonction, on a une ou zéro image (etat, caractère, direction D|G). Si elle n'était pas partielle, cela signifierai que pour chaque duet (etat, caractère), il y aurait un traitement, et la machine ne s'arreterait jamais.

Une machine augmentée avec des états finaux devient un sextuplet M = (K, \Sigma, \Gamma, \delta, q_0, F). On y rajoute F, l'ensemble de états finaux.
Contrairement aux AEF, il n'est pas obligatoire de lire entièrement le ruban. Quand la machine s'arrete, on regarde lé réponse.

Pour savoir si un mot est validé, on regarde dans quel état on est quand le symbole s'arrete.

Le langage accepté par une machine de Turing est Turing-Acceptable ou récursivement énumérable.

Si la machine de Turing s'arrête sur toutes les entrées possibles (c'est à dire pour tous les mots w, w \appartien L ou \n'appartient pas L), alors le langage est dit Turing-décidable ou récursif. On dit que M semi-décide L, ou encore M accepte L.

Les fonctions pouvant être calculés par une machine de Turing sont dites Turing-calculables.

Les fonctions de N dans N. f(I^n) = I^f(n) pour tout n \appartenant à N

Pour des machines + complexes, on utilise des machines de Turing comme des modules ou des sous-routines.

Exemple de combinaison de machine de Turing.
Les machines qui remplacent un symbole.
·Une machine pour chaque symbole de l'alphabet \Gamma.


___________________________________________________________
Cours du 18/09/2014

Notes to self:
configuration : (q, w, a, u)
-q est le symbole utilisé pour les etats de l'automate.
-a le symbole courant de \Sigma
-w la partie a gauche du symbole courant
-u la partie à droite

--> possibilité de remplacer cette écriture par (q, w_a_u)
-q l'etat courant
-w_a_u le ruban ou le symbole courant est souligné.

les transitions s'écrivent \delta(q_1, a) = (q_2, b, D|G)
-q_1 l'etat courant
-a le symbole lu
-q_2 l'etat après transition
-b le symbole lu après transition
-D|G droite ou gauche, la direction dans laquelle s'est déplacée la tete de lecture




_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
Machine de Turing a ruban infini dans les deux sens
->Au lieu d'avoir un seul blanc à gauche, on a un nbre infini de blanc à gauche.

Pour simuler une machine à ruban infini dans les deux sens M, on utilise un ruban à deux pistes (on coupe en deux de manière arbitraire le ruban de M)

on ajoute du coup le symbole $ pour signifier que on est tout à gauche.
M':
|$|i|j|k|
| |h|g|f|

M' simule M (M1'), puis on redéplie au bout (Mf), et on vérifie que le comportement est le même

M1' qque soit q € K (de M), on a 2 copies des M1' :
	<q, 1> et <q, 2> --> M1' piste du bas
	  |
	  V
M1' piste du haut

Quand M1' prime s'arrête, la tete est placée sur un symbole caractérisé (par une barre horizontale?)

M = (K, \Sigma, \Theta, \delte, F)
M1'= (K_1', \Sigma, \Theta', \delta_1', F_1')
où K_1'= (K U {qf}) * {1, 2}, qf n'appartenant pas à K
et F_1' = {qf} * {1, 2}
Le symbole $ symbolise un changement de piste (virtuel)

(a) piste du haut
si \delta(q, a_1) = (p, b, D)	(M)
alors \delta_1'(<q, 1>, \alpha_1, \alpha_2) = (<p, 1>, (b,\alpha_2), D)

et si \delta(q, \alpha_1) = (p, b, G)
alors \delta_1'(<q, (\alpha_1, \alpha_2)) = (<q, 1>, (\alpha_1, \alpha_2)) = (<p, 1>, (b, \alpha_2), G)

(b) piste du bas
si \delta(q, \alpha_1) = (p, b, D)
alors \delta_1 '(<q, 2>, (\alpha_1, \alpha_2)) = (<p, 2>, (\alpha_1, b), G)

et si on remplace D par Gauche dans la ligne de M, alors on remplace G par Droite dans la ligne de M1'

(c)Changement de piste :
Quelque soit q € K
\delta_1 (<q, 1>, $) = (<q, 2>, $, D)
et inversement :
\delta_1'(<q, 2>, $) = (<q, 1>, $, D)
(on va toujurs vers la droite quand sort du $)

(d) extension à droite : si on lit un blanc (sur deux lignes), on remplace par deux blanc (un par ligne)
qque soit q € K
\delta_1'(<q, 1>, #) = (<q, 1>, (#, #), S)		S pour Stag
\delta_1'(<q, 2>, #) = (<q, 2>, (#, #), S)

(e) Mémorisation de la tête à la fin de M1'
qque soit q € F
\delta_1'(<q, A>, (\alpha_1, \alpha_2)) = (<qf, 1>, (\alpha_1^_, \alpha_2), S)
\delta_1'(<q, 2>, (\alpha_1, \alpha_2)) = (<qf, 2>, (\alpha_1, \alpha_2^_), S)

à l'arret de M1'

_ _ _ _ _ _ _ _ _ _ _ _ _ _ _
Machine à copier à 2 rubans

(\sigma minuscule symbole courant pour les automates dessinés)

M' Simule M à k rubans
(standard)
M', 1 ruban, 2k pistes  ->k rubans
						->positions des k tetes
M' : (1) mettre $ à gauche
	 (2) diviser en 2k pistes
	 (3) #w# sur la 1ere piste
	 (4) positionner les tetes
	 (5) simulat° de M sur w
	 (6> 2k pistes -> 1 piste, place la tete, s'arrete

Possible de simuler une machine multi-dimensionnelle en linéarisant le plan.


Random Acces, Machine à Accès direct : accès à chaque case du ruban, àa la différence d'une machine de Turing à accès séquentiel
->Cette machine comporte un ruban T et ses n Cases T[0]. R_0, R_1, R_3, des registres, et K un compteur de programme, pour savoir ou on en est dans un programme.

Des instructions :
-read j -> placer ds le premier registre le contenu de la R_j eme case, R_j etant la valeur du j eme registre
-write j -> le contraire
-store j -> placer le contenu du j eme registre dans le premier registre
etc

Role particulier de R_0 : accumulateur

une machine à accès directe est un couple M  =(k, \Theta) avec k > 0 le nbre de registre, et \Theta une suite d'instruction.

On peut simuler une telle machine avec plusieurs rubans : 1 pour la mémoire, 1 pour le programme, 1 pour chaque registre. Le contenu de la mémoire est représenté par des paires de mots (adresse contenu)

Le programme indiqué en exemple dans le cours correspond à une multiplication de R_0 par R_1


Machine non déterministe : 
-> \Delta est ce coups ci un sous-ensemble de K x \Gamma x K x \Gamma x {G U D}.

On peut avoir deux sorties différentes pour une même entrée => accepteur dont le rélusatat intéressant est de savoir si la machine s'arrête ou pas.

On peut construitre pour M tte machine de Turing non déterministe une machine normale M' telle que pour tte chaine w€ \Sigma, si M s'aarête avec w en entréee, alors M' s'arrete sur w, et si M ne s'arret pas sur w, alors M' ne s'arrete pas non plus.

Simulation d'une machine M non déterministe à partir d'une machine C déterministe.

Soit C une cnfig de M. Il peut y avoir i config. C |-_M C_i. Soit d_C le nbre de config, C_i atteignable à partir de C
Le nbre de transistion de M (q, a, p, b, K)
d_C est fixé et bornjé d_C =< |K|.|\Gamma|.2
soit r le nbre de max de transistion applicable sur une config quelconque.
À partir de la config initiale (de départ) C = (q_0, _#_w#)
M définit au plus r config atteignable en 1 étape
C |-_M C_1,C |-_M C_2, etc.
Et de même pour C_1, et pour C_2, il y a r config atteignables.
À partir de C, on peut atteindre r² config en deux étapes.
M' simule M en vérifiant ttes les config atteignables en 1 étape
"													" en 2 étapes
"													" en k étapes
Si M s'arrete, donc nbre fini d'étapes, alors M' découvrira cet arret.
Si M ne s'arrete pas, M' n'arretera pas non plus la simulation 

M' machine a trois rubans : (<=> M à 1 ruban)
-Ruban (1) w, (chaine d'origine, n'est jamais modifié)
-Ruban (2) simulation de M, w recopié sur (2)
-Ruban (3) stocke la suite de config pour savoir ce qui a été fait et ce qu'il reste à faire, pour trouver la suite de config de M utilisé pour faire la config courante. On a donc sur ce ruban ##, puis une suite de mot appartenant à l'alphabet. {d_1, d_2, d_3, ...., d_r}

					 /-\
M' >$⁽²⁾D⁽^r⁾N M_1'<-   ->T
					 \-/

N copie w sur (2), après avoir effacé (2).
M_1' va simuler un calcule deterministe de M
Si M_1' s'arrête, alors
	-si le symbole courant du ruban (3) est # -> M s'est arrété en échec
	-Si le symbole courant du ruban (3) est non blanc, cela veut dire que M s'est arrété avec la config courante, donc M' s'arrête aussi.

T sur (3) à partir d'un ruban sur lequel il y a le mot #d# -> #d'# avec d' = d+1

Bon, j'ai pas réussi à prendre le dessin.... faudra que je trouve un moyen de les refaire avec Dia. ou Astah.
En gros, c'est un truc pour produire d' à partir de d sur le ruban (3)

N doit, dans un premier temps, effacer le ruban 2 pour s'assurer qu'il est vide. Étapes de l'opération
a- se déplace à droite sur (2) de la longueur du ruban (3) =< largeur (3)
b- effacement (2) G en mettant # jusqu'a $
c- N copie (1) sur (2)
d- positionne la tête (3) sur le 1 er symbole
encore un AEF dessiné. Et un gros. Il explique ce que l'on fait après l'étape d.

M_1' : même étape que M. Travaille sur (2) avec les infos (3)
-Si sur (3), on a # => simulation terminée
-Si sur (3), on a autre que #, M_1' simule une étape de M (a symbole a (2) et q etat à (2))avec la transition associée à q définie par (q, a, p_i, b_i, R).
M_1' entre ds l'etat p_i, écrit b_i sur (2) et déplace la tete de (2) selon R.

C'était écrit tout petit, il est probable qu'il y ai des fautes.

_____________________________________________________________________
Cours du 26/09

Les machines de Turing sont un formalisme assimilable à un lgge de programmation.
Les Machines de Turing Universelles restent des machines standards (pas de puissance supplémentaires).

--------------------
Grammaires

a^n b^n c^n, Langage Turing-décidable, qui s'arrete automatiquement, obligatoirement. Cela donne une réponse. (Différent de Turing-acceptable (qui inclut Turing-décidable)

Comme un langage L est engendré par une gramR génrale ssi il est récursivement énumérable, cela signifie qu'on peut simuler le fnctionnement de cette gramR avec une Machine de Turing.

SwS -> convention pour le point d'entrée. SwS =>_{G}^{*} ssi f(w) = v. C'est à dire que tte dérivation par G de SwS donne v.

ex : 
w = abba, f permute les a et les b.
SabbaS =>^{*} baab

Une fonction f : \Sigma * -> `Sigma * est grammaticalement calculable s'il existe une gramR la calculant.

Fonctions numériques :

pour une Machine de Turing, le ruban correspond aux actuelles chaines de caractères.
Une fct° passe de |N -> |N

3 fnct°s de base, 2 opérateurs sur les fnct°s de Base, et on mélange entre eux : on construit les fonctions primitives récursives, qui sont aussi la classe des fonctions calculables.

ex : f(n) = n² + 3n + 5 + 2^{n+1}
qque soit n, peut-être calulé.
-Composition d'opérations et de cnstntes
-cnstntes définies à partir de {0, succ n}
-puissance : construite à partir de produits m^n = {1 si n = 0, m.m si n différent de 0}
-Produit : construite à partir de sommes
-somme : construite à partir de succ.

Les entiers sont construits uniquement à partir de 0 et de succ.

Composition : 
p et k = 1
g : N -> N
h : N'-> N
f : N^{P} -> N f= goh
f(n1, ..., np) = g(h(n1, ..., np))

Récursivité :
-> définition avec un cas d'arret et un cas de récursivité.

id_{m, n} récupère le n eme élément d'un vecteur à m arguments.

-Addition
plus(n, O) = n
		   = id_{1,1}(n)
plus(n, M+1) = succ(plus(n, m))
			 = succ(id_{3, 3}(n, m, plus(n, m)))
			 |> Fonction h

-Multiplication :
mult N² -> N
mult(n, 0) = 0
mult(n, m+1) = plus(n, mult(n, m))

Possibilité d'écrire aussi mult(n, 0) = zéro_1(n)
= plus(id_{3, 1}(n, m, mult(n, m)), id_{3, 3}(n, m, mult(n, m)))

-Soustraction :
pred(0) = 0
pred(n + 1) = n
On obetien la soustraction non négative avec le tilde ~ (résultat >= 0)
m ~ 0 = m
m~(n+1) = pred(m ~ n)

Prédicat primitif récursif :
-iszéro -> renvoi 1 si == 0, renvoie 0 sinon

Cela permet de déduire les opérateurs de comparaison (<, =<, =, diff, >, >=:
-n =< m = iszéro(n ~ m)

Opérateur booléens ( et ^, négation !, ou v)
- !n = 1 ~ n
- n^m = 1 ~ iszéro(n * m)
- n v m = 1 ~ iszéro(n+ m)

Définition par cas :

p prédicat  ->1
			->0
f primitive récursive si g1, g2 et p le sont
f(x_1, ..., x_n) = p(x_1, ..., x_n) * g1(x_1, ..., x_n) + (1~p(x_1, ..., x_n)) * g2(x_1, ..., x_n)

Modulo :
mod(0, n) = 0
mod(m+ 1, n) = 0 si mod(m, n) ) pred(n), mod(m, n)+ 1 sinon.

div(0, n) = 0
div(m+1, n) = div(m, n) si mod(m+1, n) > 0, div(m, n) + 1 sinon.

\Somme :
sum_f(n)= f(0) + ... + f(n)
		= sum_f(0) = f(0) ou sum_f(n+1) = sum_f(n, f(n+1))
