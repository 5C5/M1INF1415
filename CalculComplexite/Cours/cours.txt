Cours de Calucl et Complexité

Cours du 11/09/2014

JFLAP : plateforme de test d'automate, de gramR, etc (cg Google).


Classifier des langages (rationnels, algébriques et récursifs), des automates associés et des gramR les engendrant.
Le décidabilité et la complexité en dépendent.


Automate finis déterministes :
-Simulation d'une machine très simple :
	-mémorisation d'un état
	-programme sous forme de graphe étiquetté indiquant les transitions possibles
-Cette machine lit un mot en entrée
-ce mot décrit une suite d'action et progresse d'état en état, jusqu'a lecture du mot.
-Et dit s'il fait partir d'un langage donné, après avoir atteint un état final.

Un automate déterministe fini est le quintuplet :
-K ensemble fini non vide d'état
-Epsilon : alphabet (ensemble non vide de lettres)
-delta : fonction de transistion K x Epsilon -> K
	ð(q, sigma) =q'


Machines de Turing :
Une machine de Turing est constituée 
-d'un contrôle (ensemble finis d'état et de transitions
-d'un ruban infini à droite
-d'une tête sur le riban qui peut lire et écrire et qui peut se déplacer dans les deux directions d'un caractère à la fois.

A chque étape, en fonction de l'état courant et du symbole courant, la machine :
-change d'état,
-écrit un symbole à l'emplacement courant,
-déplace le tête d'une position à droite ou à gauche.

Initialement la machine est dans un état initial (sic)

Le symbole qui désigne le blanc (#) n'appartient pas à l'alphabet, mais peut être lu.
Pour simplifier l'écriture des configurations, on introduit une notation abbréviée sous la forme : (état courant, contenu du ruban où le symbole courant est souligné)

Ainsi, la config (q, e, a, bcdf) s'écrit (q, _a_ bcdf)  oui, le a est souligné (je peut pas le faire en ascii).

/!\ Je passe en notation latex pour la suite

Soit une machine de Turinf M=(K, \Sigma, \Gamma, \delta, q_0) et deux configurations (q_1, w_1, a_1, u_1) et (q_2, w_2, a_2, u_2). On dit que (q_1, w_1, a_1, u_1) conduit à (q_2, w_2, a_2, u_2) en une étape ssi voir démonstration.
On note cela (q_1, w_1, a_1, u_1) \Tcouché_M (q_2, w_2, a_2, u_2)

\delta : une fonction partielle : pour chaque doublet (etat, caractère) de la fonction, on a une ou zéro image (etat, caractère, direction D|G). Si elle n'était pas partielle, cela signifierai que pour chaque duet (etat, caractère), il y aurait un traitement, et la machine ne s'arreterait jamais.

Une machine augmentée avec des états finaux devient un sextuplet M = (K, \Sigma, \Gamma, \delta, q_0, F). On y rajoute F, l'ensemble de états finaux.
Contrairement aux AEF, il n'est pas obligatoire de lire entièrement le ruban. Quand la machine s'arrete, on regarde lé réponse.

Pour savoir si un mot est validé, on regarde dans quel état on est quand le symbole s'arrete.

Le langage accepté par une machine de Turing est Turing-Acceptable ou récursivement énumérable.

Si la machine de Turing s'arrête sur toutes les entrées possibles (c'est à dire pour tous les mots w, w \appartien L ou \n'appartient pas L), alors le langage est dit Turing-décidable ou récursif. On dit que M semi-décide L, ou encore M accepte L.

Les fonctions pouvant être calculés par une machine de Turing sont dites Turing-calculables.

Les fonctions de N dans N. f(I^n) = I^f(n) pour tout n \appartenant à N

Pour des machines + complexes, on utilise des machines de Turing comme des modules ou des sous-routines.

Exemple de combinaison de machine de Turing.
Les machines qui remplacent un symbole.
·Une machine pour chaque symbole de l'alphabet \Gamma.


___________________________________________________________
Cours du 18/09/2014

Notes to self:
configuration : (q, w, a, u)
-q est le symbole utilisé pour les etats de l'automate.
-a le symbole courant de \Sigma
-w la partie a gauche du symbole courant
-u la partie à droite

--> possibilité de remplacer cette écriture par (q, w_a_u)
-q l'etat courant
-w_a_u le ruban ou le symbole courant est souligné.

les transitions s'écrivent \delta(q_1, a) = (q_2, b, D|G)
-q_1 l'etat courant
-a le symbole lu
-q_2 l'etat après transition
-b le symbole lu après transition
-D|G droite ou gauche, la direction dans laquelle s'est déplacée la tete de lecture




_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
Machine de Turing a ruban infini dans les deux sens
->Au lieu d'avoir un seul blanc à gauche, on a un nbre infini de blanc à gauche.

Pour simuler une machine à ruban infini dans les deux sens M, on utilise un ruban à deux pistes (on coupe en deux de manière arbitraire le ruban de M)

on ajoute du coup le symbole $ pour signifier que on est tout à gauche.
M':
|$|i|j|k|
| |h|g|f|

M' simule M (M1'), puis on redéplie au bout (Mf), et on vérifie que le comportement est le même

M1' qque soit q € K (de M), on a 2 copies des M1' :
	<q, 1> et <q, 2> --> M1' piste du bas
	  |
	  V
M1' piste du haut

Quand M1' prime s'arrête, la tete est placée sur un symbole caractérisé (par une barre horizontale?)

M = (K, \Sigma, \Theta, \delte, F)
M1'= (K_1', \Sigma, \Theta', \delta_1', F_1')
où K_1'= (K U {qf}) * {1, 2}, qf n'appartenant pas à K
et F_1' = {qf} * {1, 2}
Le symbole $ symbolise un changement de piste (virtuel)

(a) piste du haut
si \delta(q, a_1) = (p, b, D)	(M)
alors \delta_1'(<q, 1>, \alpha_1, \alpha_2) = (<p, 1>, (b,\alpha_2), D)

et si \delta(q, \alpha_1) = (p, b, G)
alors \delta_1'(<q, (\alpha_1, \alpha_2)) = (<q, 1>, (\alpha_1, \alpha_2)) = (<p, 1>, (b, \alpha_2), G)

(b) piste du bas
si \delta(q, \alpha_1) = (p, b, D)
alors \delta_1 '(<q, 2>, (\alpha_1, \alpha_2)) = (<p, 2>, (\alpha_1, b), G)

et si on remplace D par Gauche dans la ligne de M, alors on remplace G par Droite dans la ligne de M1'

(c)Changement de piste :
Quelque soit q € K
\delta_1 (<q, 1>, $) = (<q, 2>, $, D)
et inversement :
\delta_1'(<q, 2>, $) = (<q, 1>, $, D)
(on va toujurs vers la droite quand sort du $)

(d) extension à droite : si on lit un blanc (sur deux lignes), on remplace par deux blanc (un par ligne)
qque soit q € K
\delta_1'(<q, 1>, #) = (<q, 1>, (#, #), S)		S pour Stag
\delta_1'(<q, 2>, #) = (<q, 2>, (#, #), S)

(e) Mémorisation de la tête à la fin de M1'
qque soit q € F
\delta_1'(<q, A>, (\alpha_1, \alpha_2)) = (<qf, 1>, (\alpha_1^_, \alpha_2), S)
\delta_1'(<q, 2>, (\alpha_1, \alpha_2)) = (<qf, 2>, (\alpha_1, \alpha_2^_), S)

à l'arret de M1'

_ _ _ _ _ _ _ _ _ _ _ _ _ _ _
Machine à copier à 2 rubans

(\sigma minuscule symbole courant pour les automates dessinés)

M' Simule M à k rubans
(standard)
M', 1 ruban, 2k pistes  ->k rubans
						->positions des k tetes
M' : (1) mettre $ à gauche
	 (2) diviser en 2k pistes
	 (3) #w# sur la 1ere piste
	 (4) positionner les tetes
	 (5) simulat° de M sur w
	 (6> 2k pistes -> 1 piste, place la tete, s'arrete

Possible de simuler une machine multi-dimensionnelle en linéarisant le plan.
