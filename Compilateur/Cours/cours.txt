Cours sur les compilateurs
(Erwan Guillou)

Cours du 11/09/2014

-> Compilateur
	[Langage type Pascal] -> [représentation intermédiaire -> Robot Logo]

On part d'un langage source, qu'on passe à un compilateur, qui renvoie normalement un code binaire éxécutable.

Cela se fait en deux étapes :
-Génération d'un code intermédiaire (code trois adresses)
-Génération du code binaire à partir de ce code 3 @

Le code binaire dépend du OS et de la machine utilisé. Le code 3@, proche de se code binaire, va pouvoir être optimisé.

Dans la génération du code 3@, il y a trois étapes
-analyse lexicale (découpe le code en unité lexicale (lèxeme). On a défini au préalable tous les expressions régulières.
-analyse syntaxique : vérification de l'adéquation entre les suites de lèxemes et le langage.
-analyse sémantique : on va essayer de donner un sens (et vérifier qu'il y en a un). Elle fait la vérification d'erreur plus génération de code 3@. Elle peut également faire un certain nombre d'optimisations (simples)

Dans le passage du code 3@ au code binaire, également trois étapes :
-Optimisation par rapport à la machine.
-Allocation de registre (limiter les accès mémoire)
-Génération du code assembleur => utilisation d'instruction liées au processeur.

Prg source -> analyse lexicale -> fournit des lèxèmes -> analyse syntaxique (correspondance avec les règles du langages) -> à chaque correspondance, on fait l'analyse sémantique associée à la règle.

Langage à générer : du NBC (langage du robot)

Dans l'analyse lexicale, il nous faut une liste des identificateurs -> la table des symboles; dans un contexte donné : identificateur --> signification dans le programme.

La table des symboles peut se présenter sous la forme d'un tableau de symbole, chacun possédant une liste chainée de signfication (selon le contexte).
Une autre solution plus simple consiste à faire une table des symboles par contexte. Il devient ensuite simple de lier un contexte à un contexte parent (englobant).

/!\ En Pascal, pas de distinction entre minuscules et majuscule.

On associe à la table des symboles une table des identificateurs, qui fait le lien entre un identificateur sous la forme d'une chaîne de caractère et un numéro unique.

Analyse lexicale : 
-découpe le code en lèxème.
-Remplit la table des identificateurs si besoin (Dico)
-Calcule la valeur des constantes numériques.

On donne une description des lexèmes (et quelques action en C) à un prog appelé flesc qui donne le code C de l'analyseur lexical.

Le remplissage de la table des symboles va être un couplage l'analyse syntaxique et l'analyse sémantique.

Le langage source peut être décrit sous la forme d'une GramR.

(J'ai déjà fait tout les trucs sur les GramR, l'analyse lexicale et syntaxique, je ne prends pas la peine d'écrire l'exemple du prof. Surtout que dessiner des piles en ASCII, c'est chiant. Même si c'est de l'UTF-8. Mais libre à vous de compléter cette partie du cours).

Pile contient des couples : <Symbole, attribut>

Définitir pour chaque symbole les attributs.
Pour chaque règle, test à réaliser; calculer les nouveaux attributs.

On passe une description du langage avec attributs et règles de caluls à un outil nommé bison qui donne le code C des analysateurs syntaxiques et sémantiques.


Objectifs des TPs : définir les attributs/actions pour générer du code.

Étapes : 
-gestion des déclarations : remplir les tables des symboles -> essentiellement les variables.
-Calcul des expression constantes (tout ce qui est calculable (sauf ceux implicants des vairables, même intialisées) à la compilation doit être calculé!)

-Gestion des déclarations (constantes)
-génération de code pour expressions/intructions.
-gestion des déclarations (types).
-Optimisation
-Affectation de registres.


La gestion des déclarations : associer une signification à chaque identificateur.

->Programme : décrit par la TS principale; code 3@
->Fonction : décrite par un nbre d'argumment, la TS de son contexte, type de retour; code 3@
->Procédure (Fonction void en C) : nbre d'argumment; TS contextuelle, code3@.
->variable : définie par leur type;
->constante : définie par un type et une valeur.
->Argumment : défini par un mode de passage (adresse) et le type associé
->type utilisateur : déscription du type(quelqu'il soit)
->temporaires : (les petis trucs utilisés pour stocker les résultats des calcules intermédiaires) décrit par le type associé.
->étiquette de branchement : utilisées pour les boucles

Dans la table des symboles : n°unique identification --> signification (descripteurs)

->décrire un type

_ _ _ _ _ _ _ _ _ _ _ _ _ _
Cours du 18/09

Description d'un type

base -> entier, reel, booleen, char
tableau -> n dimensions, type d'let, intervalles
pointeur -> types des elt pointés.
structure -> n champs(nom + type)
enumeration -> liste des valeurs
intervalles -> bornes min et max + type borne
+ types utilisateurs

TS des symboles :
une valeur | type symbole | une description du type


pas de notion d'ordre dans la table des symboles, donc nécessité de rajouter des données pour ordonner : un décalage mémoire.

ex : 
var a : integer -> 16 bits
	b : array[1 5n -3 3] of real -> 32 bits
	c : boolean -> 8 bits

dans la table des symboles, on aura :
a | var | int \0
b | var | [1 5, -3 3] real \2
c | var | bool \142

Dv -> var listDecl
listDecl -> decl listDecl
		 |  decl
decl -> listid : type;

a, b : integer;

		D
	  / | \
	 /  |  \
Listid	|   Type
   /|\  :	  |
  / | \		  |
id  |  \	 integer
 |  ,  listid
 b		|
		id
		|
		b

Type ↑description
Listeid↑ liste des n° uniques

descl -> listid : Type;
	qqce id € Listeid↑liste
		ajouter ds TS une ligne |id|var|Type↑desc|

Listeid -> id, listeid_3
	Listeid↑id = {id↑numero} U Listeid_3↑liste

| id
	listeid↑liste = {id↑numero}

Type -> integer			Type↑desc = creerTypeEntier()
	 |  real
	 |	boolean
	 |	char
	 |	^type		Type↑desc = creerptr(Type↑desc)
	 ·
	 ·
	 ·
	 ·

ex : 
type jour = {lundi, mardi, .... , mercredi};
				↓
			constante
			type jour
			valeur 1

var t : jour;
t = lundi;

type date = record
				nom : jour;
				mois, annee : integer;
			end

var d = date
d.nom		-> accès au champ nom de la structure Date
[@id+decalage(date, nom)] = lundi

structure stockée dans une autre table des symboles, sous la forme
| nom | champ | jour|
| mois| champ | int |
|annee| champ | int |

struct DescType {
	int code;
	DescType * elts;
	TS * champs;
}

_ _ _ _ _ _ _ _
génération de code

code pascal --> code 3@
				|-> code simple, instructions proches de l'assembleur, non typé, jeu d'instructions réduit (une vingtaine):

-reserver n -> reserver n octets en mémoires pour les données/variables/temporaire.

-retourner n -> fin d'un sous prog retour à l'apellant.

-renvoyer x -> affecte le résultat d'une fnct° /!\ cette instruction ne termine pas la fnct°;

-fin --> fin du programme;

-nop --> ne fait rien.

Le nom du code vient de la, les instruct° ayant max trois adresses.
instruction :
x = y op z	calcul y op z stocke le résultt dans x
	  |
	  |-> + - * / && || < <= > >= == !=

x = op y
	|
	|-> - !

x = y
x = &y
x = *y
*x = y
aller à x
si y aller à x
appeller x		--> appeler un sous programme
empiler x
empiler &x	--> stocke &x dans le sommet de pile
empiler *x	--> stocke *x dans le sommet de pile
depiler x	--> destocke le sommet de pile dans x
depiler *x	--> destocke le sommet de pile dans la case de x


program test :
type to = array[1....5] of integer;
var b: ^ real;
function f (arg1 : real) : real;
var a : integer;
begin
	f = arg1* a;
end
procedure p(arg1 : integer)
begin
end
begin
	p(f(b^));
end


Table des identificateurs
test| O
to	| 1
b	| 2
f	| 3
arg1| 4
a	| 5
p	|6

Table des symboles
0	prg
1 	type	tab[1..5]/int
2	var		ptr(real)
3	fct°	arite 1, res, real
6	proc	arite 1

TS de f
4	arg	real
5	var	int

TS de P
4	arg	int

Code 3@ de f
	f : nop
		reserver 6
		to = arg1 * a			to est ecrit __tmps___ pour éviter d'être confondu avec les variables utilisateurs
		renvoyer to
		retourner &

code 3@ p
	p : nop
		reserver 0				on réserve 0 car pas d'affect ds la procedure
		retourner 2

code 3@ test
	test : nop
		   reserver 12
		   empiler &t1
		   to = *b
		   empiler to
		   appeller f
		   empiler t1
		   appeler p
		   fin


